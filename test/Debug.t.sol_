// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

import {IERC20, ERC20PresetFixedSupply} from "openzeppelin-contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol";
import {ManagedProxy} from "src/Managed.sol";
import {Drips, SplitsReceiver, StreamReceiver, StreamConfigImpl} from "src/Drips.sol";
import {AddressDriver} from "src/AddressDriver.sol";

contract DebugTest is Test {
    ERC20PresetFixedSupply token;
    Drips drips;
    AddressDriver driver;

    address internal constant ADDRESS_ACCOUNT0 = address(0x10000);
    address internal constant ADDRESS_ACCOUNT1 = address(0x20000);

    uint256 internal constant STARTING_BALANCE = 1_000_000_000e18;
    uint32 internal constant SECONDS_PER_CYCLE = 10;

    function setUp() public {
        // token
        token = new ERC20PresetFixedSupply(
            "Test Token",
            "TEST",
            STARTING_BALANCE * 2,
            address(this)
        );

        // drips
        Drips dripsLogic = new Drips(SECONDS_PER_CYCLE);
        drips = Drips(address(new ManagedProxy(dripsLogic, address(this))));

        // address driver
        uint32 driverId = drips.registerDriver(address(this));
        AddressDriver driverLogic = new AddressDriver(
            drips,
            address(0),
            driverId
        );
        driver = AddressDriver(
            address(new ManagedProxy(driverLogic, address(this)))
        );
        drips.updateDriverAddress(driverId, address(driver));

        // set up token balances
        token.transfer(ADDRESS_ACCOUNT0, STARTING_BALANCE);
        vm.prank(ADDRESS_ACCOUNT0);
        token.approve(address(driver), type(uint256).max);
        token.transfer(ADDRESS_ACCOUNT1, STARTING_BALANCE);
        vm.prank(ADDRESS_ACCOUNT1);
        token.approve(address(driver), type(uint256).max);
    }

    function testStreams() public {
        console2.log("testStreams");

        uint256 fromDripsAccId = driver.calcAccountId(ADDRESS_ACCOUNT0);
        uint256 toDripsAccId = driver.calcAccountId(ADDRESS_ACCOUNT1);

        uint32 streamId = 0;
        uint160 amtPerSec = 500 * drips.AMT_PER_SEC_MULTIPLIER();
        uint32 start = 0;
        uint32 duration = 0;

        console2.log("amtPerSec", amtPerSec);

        // function create(uint32 streamId_, uint160 amtPerSec_, uint32 start_, uint32 duration_)
        StreamReceiver[] memory receivers = new StreamReceiver[](1);
        receivers[0] = StreamReceiver(
            toDripsAccId,
            StreamConfigImpl.create(streamId, amtPerSec, start, duration)
        );

        int128 balanceDelta = 500000;
        uint32 maxEndHint1 = 0;
        uint32 maxEndHint2 = 0;

        console2.log("balanceDelta", balanceDelta);
        console2.log(
            "account 0 balance before",
            token.balanceOf(ADDRESS_ACCOUNT0)
        );

        // function setStreams(
        //     IERC20 erc20,
        //     StreamReceiver[] calldata currReceivers,
        //     int128 balanceDelta,
        //     StreamReceiver[] calldata newReceivers,
        //     uint32 maxEndHint1,
        //     uint32 maxEndHint2,
        //     address transferTo
        // ) public whenNotPaused returns (int128 realBalanceDelta) {
        console2.log("** SET STREAMS **");
        console2.log("");
        vm.prank(ADDRESS_ACCOUNT0);
        int128 realBalanceDelta = driver.setStreams(
            token,
            new StreamReceiver[](0),
            balanceDelta,
            receivers,
            maxEndHint1,
            maxEndHint2,
            ADDRESS_ACCOUNT0
        );

        console2.log("realBalanceDelta", realBalanceDelta);
        console2.log(
            "account 0 balance after",
            token.balanceOf(ADDRESS_ACCOUNT0)
        );

        console2.log("** WARP TIME **");
        console2.log("");
        uint256 cycles = 5;
        // uint256 cycles = 1;
        vm.warp(block.timestamp + cycles * SECONDS_PER_CYCLE);

        uint128 receivable = drips.receiveStreamsResult(
            toDripsAccId,
            token,
            type(uint32).max
        );
        uint32 receivableCycles = drips.receivableStreamsCycles(
            toDripsAccId,
            token
        );

        console2.log("receivable", receivable);
        console2.log("receivableCycles", receivableCycles);

        console2.log("** RECEIVE STREAMS **");
        console2.log("");

        uint128 receivedAmt = drips.receiveStreams(
            toDripsAccId,
            token,
            type(uint32).max
        );
        console2.log("receivedAmt", receivedAmt);

        console2.log("** SPLIT **");
        console2.log("");

        drips.split(toDripsAccId, token, new SplitsReceiver[](0));

        console2.log(
            "account 1 balance before",
            token.balanceOf(ADDRESS_ACCOUNT1)
        );
        console2.log("** COLLECT **");
        console2.log("");

        vm.prank(ADDRESS_ACCOUNT1);
        uint128 collected = driver.collect(token, ADDRESS_ACCOUNT1);

        console2.log("collected", collected);
        console2.log(
            "account 1 balance after",
            token.balanceOf(ADDRESS_ACCOUNT1)
        );
    }

    // function testGiveSplitCollect() public {
    //     uint256 account1Id = driver.calcAccountId(ADDRESS_ACCOUNT1);

    //     vm.prank(ADDRESS_ACCOUNT0);
    //     driver.give(account1Id, token, 1000);

    //     console2.log(
    //         "account 1 balance before",
    //         token.balanceOf(ADDRESS_ACCOUNT1)
    //     );

    //     vm.prank(ADDRESS_ACCOUNT1);
    //     drips.split(account1Id, token, new SplitsReceiver[](0));

    //     vm.prank(ADDRESS_ACCOUNT1);
    //     uint128 collected = driver.collect(token, ADDRESS_ACCOUNT1);

    //     console2.log("collected", collected);
    //     console2.log(
    //         "account 1 balance after",
    //         token.balanceOf(ADDRESS_ACCOUNT1)
    //     );
    // }
}
